---
title: "Introduction to R"
author: "Giovanni Diana"
date: "14 Oct, 2020"
output: 
   #rmarkdown::github_document:
   slidy_presentation:
      fig_height: 5
      fig_width: 7
#  ioslides_presentation:
#    widescreen: true
#    fullscreen: true
---

# Getting started

## What is R?

- Computing language for data analysis 
- Compact, fast, modular and easy to learn
- Compatible with all data formats
     + excel spreadsheets
     + text/csv
     + matlab objects
     + numpy objects
     + image data (TIFF, etc.)
- Huge R community

## What is R studio?

- Integrated Development Environment for R
- Everything connected to the same R environment
     + Data analysis
     + Notebooks
     + Presentations

## Data visualization

Besides the built-in graphics tools, there are several libraries developed for data visualization and interactive plots/apps

- [ggplot2](https://ggplot2.tidyverse.org/)
- [shiny](https://shiny.rstudio.com/)
- [plotly](https://plotly.com/graphing-libraries/)

## Notebooks

- [R Markdown](https://rmarkdown.rstudio.com/)
- [IRkernel](https://irkernel.github.io/) on `jupyter notebook`

# Data structures 

## Numbers and vectors

### Defining vectors
Vectors of fixed type (numeric or character) are define using the function "c(...)" 

```{r}
X = c("a",2,"xyz")        # vector of character types
```

There are also a number of alternative ways to generate numerical vectors:

```{r}
X = 1:10                 # integer range between 1 to 10
X = seq(0,1.5,length=20)  # sequence of 20 values between 0 and 1.5
X = rep(10,4)             # repeat 10, 4 times
X = runif(n=5)            # 5 random numbers between 0 and 1
```

### Arithmetics 
R supports vectorization of all arithmetic operations 
```{r}
X^2+2
```

## Logical type 

Boolean 0 and 1 are denoted in R by `TRUE` and `FALSE`.

Logical vectors are generated by conditions such as

```{r}
X;X>0.5
```

### AND and OR operators
in R, & and | are the logical operators of AND and OR. Can be used to combine multiple constraints
```{r}
X[X>0 & X<0.99]
```

## Subsetting vectors

We can subset vectors using logical vectors of the same dimension of the original vector
```{r}
selection = X>0.5
X[selection]
```

or by providing a vector of indices

```{r}
indexes = c(1,4,3)
X[indexes]
```

we can also extract the indices in a vector satisfying a constraint by using the function `which`
```{r}
which(X>0.5)
```

we can exclude elements from a vector by using negative indices
```{r}
X[-c(1,2)]
```


## Arrays

### Matrix
In R, we can define 2-dimensional arrays as 

```{r}
X = runif(12)
M = matrix(data=X,nrow=3,ncol=4); M
```

the data X is a 1-d vector which is reshaped into 3x4 matrix form in a "column major" fashion, i.e. 

```{r}
matrix(1:12,3,4)
```

### Multidimensional arrays

Multi dimensional arrays are defined using the `array` function
```{r}
A = array(runif(12), dim = c(2,3,2)); A # example of a 3D array (cube)
```

### Subsetting arrays

We can access array elements by providing as many indices as dimensions
```{r}
A[1,1,2]
```

and we can subset arrays as we did for vectors
```{r}
A[,2:3,] # Note the commas! Unlike python we don't need to esplicitely type ":" when selecting all elements
```


## Lists
So far we focused on data structures with fixed type (either numeric or character).
Lists in R are special containes where elements can have different types. 

```{r}
L=list()
L$vector=X  # X was a 1d array
L$matrix=M  # M is a matrix
L$name = "new list" # this is a character
print(L)
```

List elements are called by index number within double square brackets 

```{r}
L[[1]]
```

or by element name using the dollar sign notation

```{r}
L$vector
```

## Functions

The syntax to create new functions in R is 

```r
myfunction <- function(var1,var2, . . .){
  ## some code here
  return(something)
}
```
example

```{r}
mysum <- function(x,y){
  return(x+y)
}
mysum(3,4.2)
```

## Map functions on arrays

This is the array we defined earlier
```{r}
A
```

we can easily calculate the mean across layers by using the function `apply`
```{r}
apply(A,MARGIN=c(1,2),FUN=mean)
```

or the sum of columns for each layer
```{r}
apply(A,MARGIN=c(2,3),FUN=sum)
```

## Data frames

`data.frame` is the most basic class of rectangular data (rows by columns). Columns can have different type ("numeric", "character", etc). 
Let us load as an example Francisco's recordings of response amplitude and noise

```{r}
data <- read.table("../data/table.dat",header=T) #load
data1 <- subset(data,select=c("time","amplitude","baseline_var")); data1[1:6,] ## display 6 rows
summary(data1)
```

### Using the `cut` function to assign trial index
The time range is
```{r}
time_range=range(data1$time); time_range
```
and we know that each trial is 10s long. So we can use the following
```{r}
time_factors=cut(data1$time,breaks=seq(0,200000,by=10000),right=F)
levels(time_factors)
```

`time_factor` is a vector of a special type called "factor" which is used in R to denote categorical variables. In this case the factors are the time intervals of each trials. 
We can now convert these factors to numeric values and add an extra column in our dataset indicating the trial index.
```{r}
data2=cbind(data1,trial_index=as.numeric(time_factors)); data2[1:100,]
```

### Using `tapply` to calculate trial-specific statistics
Imagine we want to compute the average amplitude per trial. We can use the function `tapply` and use the `trial_index` as INDEX. 
```{r}
tapply(data2$amplitude,data2$trial_index,mean)
```

### Split data

We can also split the dataset to get one data.frame per trial
```{r}
data_split = split(data2,data2$trial_index)
```
now `data_split` is a List with as many elements as trials.


## Conditional statements and loops

### If
```r
if(statement){
   ## do things
} else {
  ## do other things
}
```

### for loop

```r
for(i in 1:N){
  # do things
}
```

### while loop

```r
while(condition){
  # do things
}
```

# Graphics

## Basic scatter plots
Let us use these data to illustrate some basic plots.
To allign repeats over time we can use the modulus operator "%%":
```{r}
data2$time = data2$time %% 10000 ## each trial is 10s long
plot(data2$time,data2$amplitude)
```

We can add some customization 
```{r}
library(viridisLite)
plot(data2$time,
     data2$amplitude,
     main="all trials",
     xlab="Time (ms)", ylab="Amplitude (pA)", 
     pch=19, ## marker style
     cex=.5, ## marker size
     col=viridis(20)[data2$trial_index]) ## color coded by trial index
```

Does baseline noise correlate with amplitude?
```{r}
plot(data$amplitude,
     data$baseline_var,
     main="amplitude vs noise",
     xlab="Amplitude (pA)", ylab="noise", 
     pch=19, ## marker style
     cex=.5) ## marker size
```

## Box plots
Box plots can be easily made by using the expression

```{r}
boxplot(amplitude ~ time, data=data2)
```

## Raster plots
```{r}
M=matrix(data$amplitude,nrow=41)
image(M,xlab="Time",ylab="trial")
```

## Histograms

```{r}
hist(M[,1],breaks=20,
     main="",
     xlab="First amplitude")
```

## Layout 
```{r}
la=layout(matrix(1:4,2,2))
par(mar=c(2,2,2,2)) ## set margins c(bottom, left, top, right) [clockwise from 6AM]
boxplot(amplitude ~ time, data=data2)
image(M,xlab="Time",ylab="trial",axes=F)
hist(M[,1],breaks=20)
boxplot(baseline_var ~ time, data=data2)
```

### More complex layouts

```{r}
matrix(c(1,1,2,2,1,1,2,2,1,1,3,3,1,1,3,3),4,4)
```

```{r}
layout(matrix(c(1,1,2,2,1,1,2,2,1,1,3,3,1,1,3,3),4,4))
par(mar=c(2,2,2,2)) ## set margins c(bottom, left, top, right) [clockwise from 6AM]
image(M,xlab="Time",ylab="trial",axes=F)
boxplot(amplitude ~ time, data=data2)
hist(M[,1],breaks=20)
```